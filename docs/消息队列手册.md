
## 消息队列的应用场景
* 流量削峰
* 解耦
* 异步
* 日志分析
## 为什么写消息队列？
消息队列可以结合 多线程编程、网络编程、系统编程、分布式、和zookeeper等组件的使用可自己设计并实现整个项目，锻炼你设计能力和解决问题的能力
## 消息队列应该有的功能
* 支持多种消息模式

    1、订阅发布模式（订阅同一个topic的多个消费者，一条消息只能由一个消费者消费）

    2、点对点模式（订阅同一个topic的多个消费者，一条消息可以由多个消费者消费）
    
    kafka的实现是引入consumer group，当然还有其他实现方式
* 支持多种获取消息的方式
    
    1、服务器主动将消息发送给consumer
    
    2、consumer主动向服务器拉取消息

    以上两种方式的各有优缺点：

    1、s->c ：获取消息及时，但是无法确定consumer端的接收速度，可能会把consumer的缓冲区打满，导致消息丢失

    2、c->s ：不需要估计consumer的接收速度，但是消息获取不及时，当消息比较少的情况下，需要consumer不断轮询服务器是否有信息
* 支持分布式（多副本）

    1、使用raft协议支持分布式（我采用了raft和fetch机制两种，raft是mit 6.824实现的raft修改了一下移植过来的）

    2、使用fetch机制（我自己整的，缺点比较多，是kafka的阉割版）实现分布式
    
    3、kafka的多副本，ISR机制，比较复杂
* 使用ack机制

    ack机制是用来选择三种模式，三种模式对数据一致性的保证是不一样的，有强一致和弱一致，可通过需要选择，如果需要响应时间短就采用 0 或 1，如果需要可用性强，一致性强就选 1（三种都支持，kafka有这个机制，可以参考）

    1、ack = -1：当消息同步到大多数节点（写入大多数节点磁盘）才返回成功
    
    2、ack = 0 ：当消息同步到leader节点（写入leader磁盘）上就返回成功

    3、ack = 1 ：当消息被leader接收（收到消息就返回）就返回
    
    问题：如果不是强一致，需要想办法将0， 1 模式未同步到其他副本节点的消息同步过去（我采用的是fetch机制，让副本节点做为consumer取pullleader上的信息，同步到本地磁盘）
* 持久化磁盘：
    
    1、写入本地磁盘，可读取历史消息，可用于日志分析（参考kafka）
    
    2、顺序读写，加快磁盘IO
    
    3、sstable加速索引查找，sstable中可存放哈希表，再次加速
* 分片：（参考kafka）
    
    1、将消息分为多个topic

    2、每个topic可分为多个partition
    
    3、我们保证每个partition的消息是有序的，不保证topic有序
    
    4、每个partition存放一个文件（文件太大就需要更换文件写）
* 分布式副本，采用muti raft的优化
    
    例如三个机器就可以组三个raft集群，每个机器负责不同的分片的服务即leader，每个机器都是leader同时又是另外两个机器的follower。
* 存储元数据（任选一个）
    
    1、采用的zookeeper

    2、kafka以前使用zookeeper，后来自己使用raft协议内置了一个类似zookeeper的，就不使用zookeeper了
    
    3、采用etcd，存储元数据也不错

    4、不使用组件，内置一个像kafka一样设计
* 负载均衡
    
    通过负载均衡算法平均分担集群压力，将高负载节点的分片转移到低负载的节点
* RPC：
    
    节点之间，server和consumer，producer之间需要通信，采用rpc简单一些，rpc可选择grpc或者字节跳动研发的kitex；
* 同时建议设计好接口，可以扩展协议，以后可以支持http协议
* 考虑如何消息才能不漏发，不重复发，不被重复消费（做幂等、做去重等）
* 生产和消费消息是一条一条发还是批量（各有优点可以尝试通过参数控制，批量可能丢消息，一条一发性能差）
* 考虑消息如何才不会丢
## 功能扩展
如果想可以再做一些功能：
* 灰度消息
* 事务消息
* 延时消息
* 读写优化，使读消息不走leader可通过follower读取，这个优化etcd的raft有做可以参考（我没做）
* 分片动态迁移（根据CPU，磁盘的负载情况动态迁移，可参考raft论文中的集群变换，是一种思路，还是比较有挑战的）
## 测试
* 单元测试：测试各部分功能是否能按预期运行
* 性能测试：测试整个MQ的并发情况、性能如何
* 错误注入：测试发生网络情况等情况下MQ的状态

    
该项目完成应该是一个真正的分布式系统，需要能在多个主机所组成的集群上工作，而不是像824的raft一样是单机去模拟多个节点来跑分布式，多太机器测试时就需要考虑如何去测，如何测试集群中各个节点数据的一致性。

## 设计图
如果整个项目由你自己设计并实现，可以画一个架构图放到readme里，这样面试官可以一目了然；

## 不同
需要减少多个同学写MQ带来的影响，大家需要尽量让各自的项目有不同的地方，这里简单说说有什么可不同的地方：

* 消息的类型，大家可扩展不同的消息类型，例如：灰度消息、死信队列、延时消息、事务消息等；

* 负载均衡，若不同消费者消费一个partition时，并且消费位置接近，是不是可以共用一个队列，让相同的消息不需要多次读磁盘；

* 动态扩展，如何安全动态扩展分布式集群

* 如何存储消息，有本地存储、存算分离等

* 如何实现分布式，raft、kafka的ISR、paxos、zab等分布式协议

* 如何存储元数据，zookeeper存、etcd存、本地存储等

* 客户端实现，大家可以做一些幂等、去重等